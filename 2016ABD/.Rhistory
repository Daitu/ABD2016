paper <- data.frame(A1 = c(38.7,41.5,43.8,44.5,45,46.0,47.7,58),
A2 = c(39.2,39.3,39.7,41.4,41.8,42.9,43.3,45.8),
A3 = c(34,35,39,40,43,43,44,45),
A4 = c(34,34.8,34.8,35.4,37.2,37.8,41.2,42.8))
apply(paper,2,mean)
dim(paper)
group <- factor(rep(1:dim(paper)[2],each = dim(paper)[1]),
labels = c("A1","A2","A3","A4"))
papergrop <- data.frame(paper = c(paper$A1,paper$A2,paper$A3,paper$A4),
group = group)
bartlett.test(paper~group,data = papergrop)
aov(paper~group,data = papergrop)
summary.aov(aov(paper~group,data = papergrop))
## p值<0.05，拒绝原假设，有差异
library(gplots)
par(family = "STKaiti",mfrow = c(1,1))
plotmeans(paper~group,data = papergrop,xlab = "实验室",ylab = "纸张光滑度",
main = "均值比较图",col = "red")
text(1:dim(paper)[2],apply(paper,2,mean) +1.5,labels = round(apply(paper,2,mean),3))
## 8.4:双因素非重复方差分析#####
## 8.4 : 考察对纤维弹性测量的误差，4个工厂，A1，A2，A3，A4
## 四个检查员 B1，B2，B3，B4，请问因素A与因素B的影响是否显著
xianwei <- data.frame(A1 = c(71.73,72.73,75.73,77.75),
A2 = c(73.75,76.74,78.77,76.74),
A3 = c(76.73,79.77,74.75,74.73),
A4 = c(71.73,73.72,70.71,69.69),
row.names = c("B1","B2","B3","B4"))
xianwei
## 双因子方差分析
gl(4,1,16,labels = c("A1","A2","A3","A4"))
gl(4,4,labels = c("B1","B2","B3","B4"))
xianweidf <- data.frame(tanxig = c(xianwei$A1,xianwei$A2,xianwei$A3,xianwei$A4),
A = gl(4,4,labels = c("A1","A2","A3","A4")),
B = gl(4,1,16,labels = c("B1","B2","B3","B4")))
aov(tanxig~A+B,data = xianweidf)
summary(aov(tanxig~A+B,data = xianweidf))
## 分别分析因素A合因素B的方差齐性
bartlett.test(tanxig~A,data = xianweidf)
bartlett.test(tanxig~B,data = xianweidf)
# 均接受方差齐性的原假设
c(28.30,23.04,18.63,14.33,3.74,8.35,5.69,2.73,2.24,3.23)> gm11(x,13)
gm11<-function(x,k)  {       n<-length(x)      x1<-numeric(n);      for(i in 1:n)        {             x1[i]<-sum(x[1:i]);           }       z1<-numeric(n)       m<-n-1       for(j in 1:m)         {             z1[j+1]<-(0.5*x1[j+1]+0.5*x1[j])           }      Yn=t(t(x[2:n]))       B<-matrix(1,nrow=n-1,ncol=2)       B[,1]<-t(t(-z1[2:n]))       u<-solve(t(B)%*%B)%*%t(B)%*%Yn;       a<-u[1];       b<-u[2];      x2<-numeric(3);       x2[1]<-x[1];       for(i in 1:13)         {             x2[1+i]=(x[1]-b/a)*exp(-a*i)+b/a;         }       x2=c(0,x2);       y=diff(x2);       y     }
## 1：一批抢弹####
data <- c(914,920,910,934,953,940,912,924,930)
t.test(data,mu = 950,conf.level = 0.99)
## p-value = 0.001 :拒绝原假设，可以认为初速有显著性降低
shuidao <- data.frame(B1 = c(19.3,19.2,21.7,22.6,20,20.1),
B2 = c(24,27.3,27.5,30.3,24.2,27.3),
B3 = c(26,28.5,29,28.7,24.5,27.1),
B4 = c(27.8,28.5,30.2,29.8,28.1,27.7),
A = rep(c("A1","A2","A3"),each = 2))
shuidao
# 给出因子水平
gl(3,2,24,labels = c("A1","A2","A3"))
gl(4,6,labels = c("B1","B2","B3","B4"))
shuidaodf = data.frame(yield = c(shuidao$B1,shuidao$B2,shuidao$B3,shuidao$B4),
A = gl(3,2,24,labels = c("A1","A2","A3")),
B = gl(4,6,labels = c("B1","B2","B3","B4")))
## 1：不同稻种的产量是否有显著的差别？哪种稻种更好些？
summary(aov(yield~A,data = shuidaodf))
boxplot(yield~A,data = shuidaodf)
summary(aov(yield~B,data = shuidaodf))
boxplot(yield~B,data = shuidaodf)
## 3:稻种和施肥量对产量的影响那个更大些？
summary(aov(yield~A+B,data = shuidaodf))
# 两种影响都是显著的
par(mfrow = c(1,2))
plot(yield~A+B,data = shuidaodf)
## 4：稻种和施肥量有无交互作用
summary(aov(yield~A+B+A:B,data = shuidaodf))
summary(aov(yield~A:B,data = shuidaodf))
# 若只考虑交互作用，则交互作用地显著的
par(mfrow = c(1,2))
interaction.plot(shuidaodf$A,shuidaodf$B,shuidaodf$yield)
interaction.plot(shuidaodf$B,shuidaodf$A,shuidaodf$yield)
par(mfrow = c(1,1))
interaction.plot(shuidaodf$A,shuidaodf$B,shuidaodf$yield)
mouse<-data.frame( X = c( 2, 4, 3, 2, 4, 7, 7, 2, 2, 5, 4, 5, 6,
8, 5, 10, 7, 12, 12, 6, 6, 7, 11, 6, 6, 7, 9, 5, 5, 10, 6, 3, 10),
A = factor(rep(1:3, c(11, 10, 12)))) #A为因子向量
mouse.lm<-lm(X ~ A, data=mouse) #一元线性回归
anova(mouse.lm) #提取方差分析表
View(mouse)
attach(mouse)
tapply(X, A, mean) #计算因素A的均值
pairwise.t.test(X, A) #多重t检验
plot(X~A) #绘出各水平的箱线图
detach(mouse)
solvefunction <- function(x){
x^3-x-1
}
D(solvefunction)
expression(solvefunction)
solvefunction <- function(x){
fun <- x^3-x-1
dfun <- 3*x^2-1
}
fun(1)
solvefunction(1)
solvefunction <- function(x){
fun <- x^3-x-1
dfun <- 3*x^2-1
return(fun,dfun)
}
solvefunction(1)
solvefunction <- function(x){
fun <- x^3-x-1
dfun <- 3*x^2-1
result <- c(fun,dfun)
return(result)
}
solvefunction(1)
solvefunction <- function(x){
fun <- x^3-x-1  # fun :求根方程
dfun <- 3*x^2-1   # dfun :求根方程导函数
result <- c(fun,dfun)
return(result)
}
nowton <- function(fun,a,k,ee=10^(-5)){
# fun :求解方程  k:最大迭代次数
# a :初始求根点  ee=10^(-5)：精度
x0 = a
for (ii in 1:seq(1,k)) {
x <- x0-solvefuntion(x0)[1]/solvefuntion(x0)[2]
if (x-x0 < ee) return(x)
}
if (ii==k) "迭代求解失败"
}
ans <- nowton(solvefunction,2,1000)
nowton <- function(fun,a,k,ee=10^(-5)){
# fun :求解方程  k:最大迭代次数
# a :初始求根点  ee=10^(-5)：精度
x0 = a
for (ii in seq(1,k)) {
x <- x0-solvefuntion(x0)[1]/solvefuntion(x0)[2]
if (x-x0 < ee) return(x)
}
if (ii==k) "迭代求解失败"
}
ans <- nowton(solvefunction,2,1000)
nowton <- function(fun,a,k,ee=10^(-5)){
# fun :求解方程  k:最大迭代次数
# a :初始求根点  ee=10^(-5)：精度
x0 = a
for (ii in seq(1,k)) {
x <- x0-fun(x0)[1]/fun(x0)[2]
if (x-x0 < ee) return(x)
}
if (ii==k) "迭代求解失败"
}
ans <- nowton(solvefunction,2,1000)
ans
solvefunction <- function(x){
x^3-x-1
}
# 编写二分法求解方程
twosol <- function(a,b,ee=10^(-5)){
#a：左边界，b：右边界，ee=10^(-5)：精度
if (solvefunction(a)*solvefunction(b) > 0 | a > b)
print("请更改边界")
else
while(abs(a-b)>=ee) {
c <- (a+b)/2
if (solvefunction(c) == 0)
return(c)
if (solvefunction(a)*solvefunction(c)<0)
b <- c
if (solvefunction(c)*solvefunction(b)<0)
a <- c
}
return(c)
}
answ <- twosol(1,2,ee=10^(-5))
answ
solvefunction2 <- function(x){
fun <- x^3-x-1  # fun :求根方程
dfun <- 3*x^2-1   # dfun :求根方程导函数
result <- c(fun,dfun)
return(result)
}
nowton <- function(fun,a,k,ee=10^(-5)){
# fun :求解方程  k:最大迭代次数
# a :初始求根点  ee=10^(-5)：精度
x0 = a
for (ii in seq(1,k)) {
x <- x0-fun(x0)[1]/fun(x0)[2]
if (x-x0 < ee) return(x)
else x0 <- x
}
if (ii==k) "迭代求解失败"
}
ans <- nowton(solvefunction2,2,1000)
ans
nowton <- function(fun,a,k,ee=10^(-6)){
# fun :求解方程  k:最大迭代次数
# a :初始求根点  ee=10^(-6)：精度
x0 = a
for (ii in seq(1,k)) {
x <- x0-fun(x0)[1]/fun(x0)[2]
if (x-x0 < ee) return(x)
else x0 <- x
}
if (ii==k) "迭代求解失败"
}
ans <- nowton(solvefunction2,2,1000)
ans
mouse<-data.frame( X = c( 2, 4, 3, 2, 4, 7, 7, 2, 2, 5, 4, 5, 6,
8, 5, 10, 7, 12, 12, 6, 6, 7, 11, 6, 6, 7, 9, 5, 5, 10, 6, 3, 10),
A = factor(rep(1:3, c(11, 10, 12)))) #A为因子向量
mouse.lm<-lm(X ~ A, data=mouse) #一元线性回归
anova(mouse.lm) #提取方差分析表
attach(mouse)
tapply(X, A, mean) #计算因素A的均值
pairwise.t.test(X, A) #多重t检验
plot(X~A) #绘出各水平的箱线图
detach(mouse)
solvefunction2 <- function(x){
fun <- x^3-x-1  # fun :求根方程
dfun <- 3*x^2-1   # dfun :求根方程导函数
result <- c(fun,dfun)
return(result)
}
nowton <- function(fun,a,k,ee=10^(-6)){
# fun :求解方程  k:最大迭代次数
# a :初始求根点  ee=10^(-6)：精度
x0 = a
for (ii in seq(1,k)) {
x <- x0-fun(x0)[1]/fun(x0)[2]
if (x-x0 < ee) return(x)
else x0 <- x
}
if (ii==k) "迭代求解失败"
}
ans <- nowton(solvefunction2,100,1000)
ans
ans <- nowton(solvefunction2,1.5,1000)
ans
twosol <- function(a,b,ee=10^(-5)){
#a：左边界，b：右边界，ee=10^(-5)：精度
if (solvefunction(a)*solvefunction(b) > 0 | a > b)
print("请更改边界")
else
while(abs(a-b)>=ee) {
c <- (a+b)/2
if (solvefunction(c) == 0)
return(c)
if (solvefunction(a)*solvefunction(c)<0)
b <- c
if (solvefunction(c)*solvefunction(b)<0)
a <- c
}
return(c)
}
answ <- twosol(1,2,ee=10^(-5))
answ
solvefunction <- function(x){
x^3-x-1
}
# 编写二分法求解方程
twosol <- function(a,b,ee=10^(-5)){
#a：左边界，b：右边界，ee=10^(-5)：精度
if (solvefunction(a)*solvefunction(b) > 0 | a > b)
print("请更改边界")
else
while(abs(a-b)>=ee) {
c <- (a+b)/2
if (solvefunction(c) == 0)
return(c)
if (solvefunction(a)*solvefunction(c)<0)
b <- c
if (solvefunction(c)*solvefunction(b)<0)
a <- c
}
return(c)
}
answ <- twosol(1,2,ee=10^(-5))
answ
a<- 1:10
a
summary(a)
lindata <- c(25,45,50,54,55,61,64,68,72,75,75,78,79,81,83,84,
84,84,85,86,87,89,89,90,91,91,92,100)
summary(lindata)
boxplot(lindata)
prod(lindata)
data1 <- data.frame(INDEX = c(1,2,3,5),
VALUE = c(10:13))
data1
rowsum(data1)
rowSums(data1)
colSums(data1)
data2<-data1[3,]=NULL
data2<-data1[3,] <- NULL
data2<-(data1[3,] <- NULL)
data1[3,] <- NULL
data1[3,]
data1[3,] = []
data1[3,] = NULL
data2<-data1[-3,]
data2
factorial(choose(min(5*sin(pi/2),8),floor(3.2)))
lindata <- c(25,45,50,54,55,61,64,68,72,75,75,78,79,81,83,84,
84,84,85,86,87,89,89,90,91,91,92,100)
summary(lindata)
boxplot(lindata)
fivenum(lindata)
prod(lindata)
data1 <- data.frame(INDEX = c(1,2,3,5),
VALUE = c(10:13))
data1
rowSums(data1)
colSums(data1)
data2<-data1[-3,]
factorial(choose(min(5*sin(pi/2),8),floor(3.2)))
shiny::runApp('R/我的练习/first_shiny')
runApp('R/我的练习/first_shiny')
runApp('R/我的练习/first_shiny')
runApp('R/我的练习/first_shiny')
library(dplyr)
dplyr::tbl_df(iris)
irisdata <- dplyr::tbl_df(iris)
irisdata
View(irisdata)
dplyr::glimpse(iris)
utils::View(iris)
utils::View(irisdata)
knit_with_parameters('~/R/我的练习/studyRmarkdown.Rmd')
install.packages("caret")
48.2-39.9
prop.test(0.083)
0.083-0.07
0.1-0.083
-2.4+0.02*30000+0.2
log(597.8)
prop.test(0.4,100)
x <- c(6,10,9,9,16,12,16,5,10,12,8)
y <- c(5,7,6,6,9,8,13,5,10,12,10)
lm(y~x)
summary(lm(y~x))
10.5-2
8.5*1.5
24.5+0.56*70.3
prop.test(125/400,400)
prop.test(125/400,400,0.25)
125/400
a <- c(10,30,10,20,40,20,30,30,10)
b <-matrix(a,3,3)
b
chisq.test(b)
24.5+0.56*70.3
exp(63.868)/(exp(63.868)+1)
1/(1+exp(-63.868))
-2.45+0.02*30+0.08*16
-0.57+0.2
exp(-0.57)/(exp(-0.57)+1)
exp(-0.37)/(exp(-0.37)+1)
install.packages("ISLR")
library(ILSR)
library(ISLR)
Weekly
head(Weekly)
glm(Direction~Lag1 +Lag2+Lag3+lag4+Lag5+Volume)
glm(Direction~Lag1 +Lag2+Lag3+lag4+Lag5+Volume,data = Weekly)
glm(Direction~Lag1 +Lag2+Lag3+Lag4+Lag5+Volume,data = Weekly)
y <- as.factor(Weekly$Direction)
y
y <- as.factor(Weekly$Direction,levels = c("Up","Down"),labels = c(1,0))
y <- as.factor(Weekly$Direction,levels = c(1,0),labels = c("Up","Down"))
y
y <- as.factor(Weekly$Direction,labels = c(0,1))
y <- factor(Weekly$Direction,labels = c(0,1))
y
x <- Weekly[,2:7]
head(x)
glm(x,y)
y <- as.integer(y)
y
glm(x,y)
glm(x,y,family = binomial(link = logit))
dim(x)
dim(y)
y
length(y)
glm(Direction~Lag1 +Lag2+Lag3+Lag4+Lag5+Volume,data = Weekly,family = binomial(link = logit))
a <- glm(Direction~Lag1 +Lag2+Lag3+Lag4+Lag5+Volume,data = Weekly,family = binomial(link = logit))
summary(a)
edit(coxph)
edit(rq)
library(MASS)
library(survival)
edit(coxph())
edit(coxph
)
edit(rq)
library(quantreg)
edit(rq)
arudata <- read.transactions(file = "第二题数据/店铺_商品.txt",format = "single",
sep = ",",cols = c(1,2),rm.duplicates = TRUE)
## 查看数据
summary(arudata)
inspect(arudata[1:2])
setwd("/Users/daitu/数据分析/2016ABD")
getwd()
rm(list = ls());gc()
## 加载所需要的包-----------------------------------
library(dplyr)
library(ggplot2)
library(arules)
library(gridExtra)
library(stringr)
arudata <- read.transactions(file = "第二题数据/店铺_品牌.txt",format = "single",
sep = ",",cols = c(1,2),rm.duplicates = TRUE)
## 查看数据
summary(arudata)
inspect(arudata[1:5])
par(family = "STKaiti",cex = 0.75)
itemFrequencyPlot(arudata,type = "absolute",topN = 30,main = "品牌频率图top30",
xlab = "品牌名",ylab = "频数",col = "LightSkyBlue")
par(family = "STKaiti",cex = 0.75)
itemFrequencyPlot(arudata,type = "relative",topN = 30,main = "品牌频率图top30",
xlab = "品牌名",ylab = "频率",col = "LightSkyBlue")
par(family = "STKaiti",cex = 0.75)
arules::image(arudata,xlab = "brand number",ylab = "shop number",main = "shops--brands")
par(family = "STKaiti",cex = 0.75)
arules::image(arudata,xlab = "brand number",ylab = "shop number",main = "shops--brands")
## 训练模型
myrule <- apriori(data = arudata,
parameter = list(support = 0.005,
confidence = 0.5,
minlen = 1))
summary(myrule)
inspect(myrule[1:10])
## 将规则按照支持度排序
sortsupport <- arules::sort(myrule,decreasing = TRUE,by = "support")
inspect(sortsupport[1:15])
## 将规则按照置信度排序
sortconf <- arules::sort(myrule,decreasing = TRUE,by = "confidence")
inspect(sortconf[1:15])
## 将规则按照提升度排序
sortlift <- arules::sort(myrule,decreasing = TRUE,by = "lift")
inspect(sortlift[1:15])
## 将关联规则数据转化为数据表格的形式
brand_shop_ruledf <- as(myrule,"data.frame")
write.csv(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.txt",
row.names = FALSE,quote = FALSE,sep = ",")
utils::write.csv(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.txt",
row.names = FALSE,quote = FALSE,sep = ",")
utils::write.csv(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.txt",
row.names = FALSE,quote = FALSE)
utils::write.csv(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.csv",
row.names = FALSE,quote = FALSE)
utils::write.csv(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.csv",
row.names = FALSE,quote = FALSE,fileEncoding = "UTF-8")
utils::write.csv(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.csv",
row.names = FALSE,quote = FALSE,fileEncoding = "UTF-8")
utils::write.csv(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.txt",
row.names = FALSE,quote = FALSE,fileEncoding = "UTF-8")
base::write(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.csv",
row.names = FALSE,quote = FALSE,sep = ",")
base::write(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.csv",
quote = FALSE,sep = ",")
base::write(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.csv",
sep = ",")
utils::write(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.txt",
row.names = FALSE,quote = FALSE,fileEncoding = "UTF-8")
utils::write.csv(brand_shop_ruledf,file = "第二题数据/店铺_品牌_关联结果.txt",
row.names = FALSE,quote = FALSE,fileEncoding = "UTF-8")
write.csv(arule_brand,file = "第二题数据/店铺_品牌.txt",row.names = FALSE)
arudata <- read.transactions(file = "第二题数据/店铺_商品.txt",format = "single",
sep = ",",cols = c(1,2),rm.duplicates = TRUE)
## 查看数据
summary(arudata)
inspect(arudata[1:2])
## 可视化商品的频率图
## itemFrequency(item_arules)
par(family = "STKaiti",cex = 0.75)
itemFrequencyPlot(arudata,type = "absolute",topN = 50,main = "商品频率图top50",
xlab = "商品编号",ylab = "频数",col = "LightSkyBlue")
par(family = "STKaiti",cex = 0.75)
itemFrequencyPlot(arudata,type = "relative",topN = 50,main = "商品频率图top50",
xlab = "商品编号",ylab = "频率",col = "LightSkyBlue")
## 可以看出出现次数最多的商品大约出现了200多次，并且top50的商品出现次数均大于50次，
## 但是商品出现的频率均偏低。
## 查看店铺和商品的稀疏矩阵图像
par(family = "STKaiti",cex = 0.75,mai = c(0,1,0,1))
arules::image(arudata,xlab = "item number",ylab = "shop number",main = "shops--items")
# ## 计算各个项集的频率
# fsets <- eclat(item_arules,parameter = list(support = 0.005,maxlen = 10))
#
# inspect(sort(fsets,by = "support"))
## 训练模型
myrule <- apriori(data = arudata,
parameter = list(support = 0.001,
confidence = 0.9,
minlen = 2))
summary(myrule)
inspect(myrule[1:5])
## 将规则按照支持度排序
sortsupport <- arules::sort(myrule,decreasing = TRUE,by = "support")
inspect(sortsupport[1:10])
## 将规则按照置信度排序
sortconf <- arules::sort(myrule,decreasing = TRUE,by = "confidence")
inspect(sortconf[1:10])
## 将规则按照提升度排序
sortlift <- arules::sort(myrule,decreasing = TRUE,by = "lift")
inspect(sortlift[1:10])
## 将关联规则数据转化为数据表格的形式
item_shop_ruledf <- as(myrule,"data.frame")
## 我门可以发现，我门发现的2000多条的规则中，置信度非常的接近1
## 并且提升度也很大，这时因为很多店铺销售的东西都很相似
utils::write.csv(item_shop_ruledf,file = "第二题数据/店铺_商品_关联结果.txt",
row.names = FALSE,quote = FALSE,fileEncoding = "UTF-8")
